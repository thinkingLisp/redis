typedef struct
{
    int a;
    char b;
}A_t;
typedef struct
{
    int a;
    char b;
    char c;
}B_t;
typedef struct
{
    char a;
    int b;
    char c;
}C_t;
void main()
{
    char*a=0;
    cout<<sizeof(a)<<endl;//4
    cout<<sizeof(*a)<<endl;//1--这个能理解
         cout<<sizeof(A_t)<<endl;//8
         cout<<sizeof(B_t)<<endl;//8
    cout<<sizeof(C_t)<<endl;//12
}
为什么是这样的结果啊？


2. 语法： 
sizeof有三种语法形式，如下： 
1) sizeof( object ); // sizeof( 对象 ); 
2) sizeof( type_name ); // sizeof( 类型 ); 
3) sizeof object; // sizeof 对象; 




5. 指针变量的sizeof 
既然是来存放地址的，那么它当然等于计算机内部地址总线的宽度。所以在32位计算机中，一

个指针变量的返回值必定是4（以字节为单位），可以预计，在将来的64位系统

中指针变量的sizeof结果为8。 
char* pc = "abc"; 
int* pi; 
string* ps; 
char** ppc = &pc; 
void (*pf)();// 函数指针 
sizeof( pc ); // 结果为4 
sizeof( pi ); // 结果为4 
sizeof( ps ); // 结果为4 
sizeof( ppc ); // 结果为4 
sizeof( pf );// 结果为4 
指针变量的sizeof值与指针所指的对象没有任何关系，正是由于所有的指针变量所占内存

大小相等，所以MFC消息处理函数使用两个参数WPARAM、LPARAM就能传递各种复杂的消息结

构（使用指向结构体的指针）。 


6. 数组的sizeof 
数组的sizeof值等于数组所占用的内存字节数，如： 
char a1[] = "abc"; 
int a2[3]; 
sizeof( a1 ); // 结果为4，字符串末尾还存在一个NULL终止符 
sizeof( a2 ); // 结果为3*4=12（依赖于int） 
一些朋友刚开始时把sizeof当作了求数组元素的个数，现在，你应该知道这是不对的，那

么应该怎么求数组元素的个数呢？Easy，通常有下面两种写法： 
int c1 = sizeof( a1 ) / sizeof( char ); // 总长度/单个元素的长度 
int c2 = sizeof( a1 ) / sizeof( a1[0] ); // 总长度/第一个元素的长度 
写到这里，提一问，下面的c3，c4值应该是多少呢？ 
void foo3(char a3[3]) 
{ 
int c3 = sizeof( a3 ); // c3 == 
} 
void foo4(char a4[]) 
{ 
int c4 = sizeof( a4 ); // c4 == 
} 
也许当你试图回答c4的值时已经意识到c3答错了，是的，c3!=3。这里函数参数a3已不再是

数组类型，而是蜕变成指针，相当于char* a3，为什么？仔细想想就不难明白，我们调用

函数foo1时，程序会在栈上分配一个大小为3的数组吗？不会！数组是“传址”的，调用者

只需将实参的地址传递过去，所以a3自然为指针类型（char*），c3的值也就为4。 

7. 结构体的sizeof 
这是初学者问得最多的一个问题，所以这里有必要多费点笔墨。让我们先看一个结构体：


struct S1 
{ 
char c; 
int i; 
}; 
问sizeof(s1)等于多少？聪明的你开始思考了，char占1个字节，int占4个字节，那么加起

来就应该是5。是这样吗？你在你机器上试过了吗？也许你是对的，但很可能你是错的！V

C6中按默认设置得到的结果为8。 
Why？为什么受伤的总是我？ 
请不要沮丧，我们来好好琢磨一下sizeof的定义——sizeof的结果等于对象或者类型所占

的内存字节数，好吧，那就让我们来看看S1的内存分配情况： 
S1 s1 = {  a , 0xFFFFFFFF }; 
定义上面的变量后，加上断点，运行程序，观察s1所在的内存，你发现了什么？ 
以我的VC6.0为例，s1的地址为0x0012FF78，其数据内容如下： 
0012FF78: 61 CC CC CC FF FF FF FF 
发现了什么？怎么中间夹杂了3个字节的CC？看看MSDN上的说明： 
When applied to a structure type or variable, sizeof returns the actual size, 

which may include padding bytes inserted for alignment. 
原来如此，这就是传说中的字节对齐啊！一个重要的话题出现了。 
为什么需要字节对齐？计算机组成原理教导我们这样有助于加快计算机的取数速度，否则

就得多花指令周期了。为此，编译器默认会对结构体进行处理（实际上其它地方的数据变

量也是如此），让宽度为2的基本数据类型（short等）都位于能被2整除的地址上，让宽度

为4的基本数据类型（int等）都位于能被4整除的地址上，以此类推。这样，两个数中间就

可能需要加入填充字节，所以整个结构体的sizeof值就增长了。 
让我们交换一下S1中char与int的位置： 
struct S2 
{ 
int i; 
char c; 
}; 
看看sizeof(S2)的结果为多少，怎么还是8？再看看内存，原来成员c后面仍然有3个填充字

节，这又是为什么啊？别着急，下面总结规律。 

字节对齐的细节和编译器实现相关，但一般而言，满足三个准则： 
1) 结构体变量的首地址能够被其最宽基本类型成员的大小所整除； 
2) 结构体每个成员相对于结构体首地址的偏移量（offset）都是成员大小的整数倍，如有

需要编译器会在成员之间加上填充字节（internal adding）； 
3) 结构体的总大小为结构体最宽基本类型成员大小的整数倍，如有需要编译器会在最末一

个成员之后加上填充字节（trailing padding）。 
对于上面的准则，有几点需要说明： 
1) 前面不是说结构体成员的地址是其大小的整数倍，怎么又说到偏移量了呢？因为有了第

1点存在，所以我们就可以只考虑成员的偏移量，这样思考起来简单。想想为什么。 
结构体某个成员相对于结构体首地址的偏移量可以通过宏offsetof()来获得，这个宏也在

stddef.h中定义，如下： 
#define offsetof(s,m) (size_t)&(((s *)0)->m) 
例如，想要获得S2中c的偏移量，方法为 
size_t pos = offsetof(S2, c);// pos等于4 
2) 基本类型是指前面提到的像char、short、int、float、double这样的内置数据类型，

这里所说的“数据宽度”就是指其sizeof的大小。由于结构体的成员可以是复合类型，比

如另外一个结构体，所以在寻找最宽基本类型成员时，应当包括复合类型成员的子成员，

而不是把复合成员看成是一个整体。但在确定复合类型成员的偏移位置时则是将复合类型

作为整体看待。 
这里叙述起来有点拗口，思考起来也有点挠头，还是让我们看看例子吧（具体数值仍以VC

6为例，以后不再说明）： 
struct S3 
{ 
char c1; 
S1 s; 
char c2 
}; 
S1的最宽简单成员的类型为int，S3在考虑最宽简单类型成员时是将S1“打散”看的，所以

S3的最宽简单类型为int，这样，通过S3定义的变量，其存储空间首地址需要被4整除，整

个sizeof(S3)的值也应该被4整除。 
c1的偏移量为0，s的偏移量呢？这时s是一个整体，它作为结构体变量也满足前面三个准则

，所以其大小为8，偏移量为4，c1与s之间便需要3个填充字节，而c2与s之间就不需要了，

所以c2的偏移量为12，算上c2的大小为13，13是不能被4整除的，这样末尾还得补上3个填

充字节。最后得到sizeof(S3)的值为16。 
通过上面的叙述，我们可以得到一个公式： 
结构体的大小等于最后一个成员的偏移量加上其大小再加上末尾的填充字节数目，即： 


sizeof( struct ) = offsetof( last item ) + sizeof( last item ) + sizeof( trail

ing padding ) 

到这里，朋友们应该对结构体的sizeof有了一个全新的认识，但不要高兴得太早，有一个

影响sizeof的重要参量还未被提及，那便是编译器的pack指令。它是用来调整结构体对齐

方式的，不同编译器名称和用法略有不同，VC6中通过#pragma pack实现，也可以直接修改

/Zp编译开关。#pragma pack的基本用法为：#pragma pack( n )，n为字节对齐数，其取值

为1、2、4、8、16，默认是8，如果这个值比结构体成员的sizeof值小，那么该成员的偏移

量应该以此值为准，即是说，结构体成员的偏移量应该取二者的最小值，公式如下： 
offsetof( item ) = min( n, sizeof( item ) ) 
再看示例： 
#pragma pack(push) // 将当前pack设置压栈保存 
#pragma pack(2)// 必须在结构体定义之前使用 
struct S1 
{ 
char c; 
int i; 
}; 
struct S3 
{ 
char c1; 
S1 s; 
char c2 
}; 
#pragma pack(pop) // 恢复先前的pack设置 
计算sizeof(S1)时，min(2, sizeof(i))的值为2，所以i的偏移量为2，加上sizeof(i)等于

6，能够被2整除，所以整个S1的大小为6。 
同样，对于sizeof(S3)，s的偏移量为2，c2的偏移量为8，加上sizeof(c2)等于9，不能被

2整除，添加一个填充字节，所以sizeof(S3)等于10。 
现在，朋友们可以轻松的出一口气了， 

还有一点要注意，“空结构体”（不含数据成员）的大小不为0，而是1。试想一个“不占

空间”的变量如何被取地址、两个不同的“空结构体”变量又如何得以区分呢？于是，“

空结构体”变量也得被存储，这样编译器也就只能为其分配一个字节的空间用于占位了。

如下： 
struct S5 { }; 
sizeof( S5 ); // 结果为1 


8. 含位域结构体的sizeof 
前面已经说过，位域成员不能单独被取sizeof值，我们这里要讨论的是含有位域的结构体

的sizeof，只是考虑到其特殊性而将其专门列了出来。 
C99规定int、unsigned int和bool可以作为位域类型，但编译器几乎都对此作了扩展，允

许其它类型类型的存在。 
使用位域的主要目的是压缩存储，其大致规则为： 
1) 如果相邻位域字段的类型相同，且其位宽之和小于类型的sizeof大小，则后面的字段将

紧邻前一个字段存储，直到不能容纳为止； 
2) 如果相邻位域字段的类型相同，但其位宽之和大于类型的sizeof大小，则后面的字段将

从新的存储单元开始，其偏移量为其类型大小的整数倍； 
3) 如果相邻的位域字段的类型不同，则各编译器的具体实现有差异，VC6采取不压缩方式

，Dev-C++采取压缩方式； 
4) 如果位域字段之间穿插着非位域字段，则不进行压缩； 
5) 整个结构体的总大小为最宽基本类型成员大小的整数倍。 

还是让我们来看看例子。 
示例1： 
struct BF1 
{ 
char f1 : 3; 
char f2 : 4; 
char f3 : 5; 
}; 
其内存布局为： 
|_f1__|__f2__|_|____f3___|____| 
|_|_|_|_|_|_|_|_|_|_|_|_|_|_|_|_| 
0 3   7 8   1316 
位域类型为char，第1个字节仅能容纳下f1和f2，所以f2被压缩到第1个字节中，而f3只能

从下一个字节开始。因此sizeof(BF1)的结果为2。 
示例2： 
struct BF2 
{ 
char f1 : 3; 
short f2 : 4; 
char f3 : 5; 
}; 
由于相邻位域类型不同，在VC6中其sizeof为6，在Dev-C++中为2。 
示例3： 
struct BF3 
{ 
char f1 : 3; 
char f2; 
char f3 : 5; 
}; 
非位域字段穿插在其中，不会产生压缩，在VC6和Dev-C++中得到的大小均为3。 


9. 联合体的sizeof 
结构体在内存组织上是顺序式的，联合体则是重叠式，各成员共享一段内存，所以整个联

合体的sizeof也就是每个成员sizeof的最大值。结构体的成员也可以是复合类型，这里，

复合类型成员是被作为整体考虑的。 
所以，下面例子中，U的sizeof值等于sizeof(s)。 
union U 
{ 
int i; 
char c; 
S1 s; 
};
